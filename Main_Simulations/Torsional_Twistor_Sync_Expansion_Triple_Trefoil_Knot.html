<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triple Trefoil Quaternion Equilibrium</title>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- MathJax -->
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      options: {
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap');

        :root {
            --bg-color: #05070a;
            --panel-bg: rgba(15, 18, 24, 0.95);
            --text-primary: #e0e0e0;
            --accent-gold: #ffd700;
            --accent-cyan: #00f2ff;
            --accent-magenta: #ff0055;
            --accent-white: #ffffff;
            --border-color: #2d333b;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            background: radial-gradient(circle at center, #12141a 0%, #000000 100%);
        }

        #sidebar {
            width: 480px;
            min-width: 480px;
            background: var(--panel-bg);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .section {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        h2 {
            font-size: 1.0rem;
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h3 {
            font-size: 0.9rem;
            margin: 15px 0 5px 0;
            color: #fff;
            border-left: 3px solid var(--accent-gold);
            padding-left: 10px;
        }

        /* Controls */
        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-bottom: 4px;
            font-weight: 500;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
        }
        
        /* Checkbox styling */
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            font-size: 0.8rem;
            color: var(--text-primary);
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-cyan);
            cursor: pointer;
        }

        /* Overlay UI */
        #canvas-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            background: rgba(0,0,0,0.6);
            padding: 6px 12px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
            color: white;
            border-left: 3px solid transparent;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        
        .legend-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }
        
        .legend-item.active {
            background: rgba(255,255,255,0.2);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #reset-btn {
            margin-top: 10px;
            padding: 6px 12px;
            background: rgba(45, 51, 59, 0.8);
            border: 1px solid var(--border-color);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 0.75rem;
            text-transform: uppercase;
            width: fit-content;
        }
        
        #reset-btn:hover {
            background: var(--accent-cyan);
            color: black;
        }
        
        .math-block {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            color: #ccc;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>

    <!-- 3D Visualization Container -->
    <div id="canvas-container">
        <div id="canvas-ui">
            <div id="phase-alpha" class="legend-item" style="border-color:#ff0055" onclick="highlightPhase(0)">
                <strong>Phase Alpha</strong> (Stream 1 + Inverse)
            </div>
            <div id="phase-beta" class="legend-item" style="border-color:#00f2ff" onclick="highlightPhase(1)">
                <strong>Phase Beta</strong> (Stream 2 + Inverse)
            </div>
            <div id="phase-gamma" class="legend-item" style="border-color:#ffd700" onclick="highlightPhase(2)">
                <strong>Phase Gamma</strong> (Stream 3 + Inverse)
            </div>
            <div id="phase-delta" class="legend-item" style="border-color:#ffffff; opacity:0.9" onclick="highlightPhase(3)">
                <strong>Emergent Phase 4</strong> (Quaternion Centroid)
            </div>
            <div class="legend-item" style="margin-top:5px; border-left:none; opacity:0.8" onclick="highlightPhase(-1)">
                Reset Focus (Show All)
            </div>
            <button id="reset-btn" onclick="resetCamera()">Reset View</button>
        </div>
    </div>

    <!-- Sidebar -->
    <div id="sidebar">
        
        <div class="section">
            <h2>Quaternion Mechanics</h2>
            
            <div class="control-group">
                <label>Micro-Twist (Quaternion Rotation) <span id="val-twist">0.0</span></label>
                <input type="range" id="input-twist" min="0" max="15" step="0.01" value="2.5">
            </div>

            <div class="control-group">
                <label>Stream Expansion (Tube Radius) <span id="val-buckle">0.0</span></label>
                <input type="range" id="input-buckle" min="0.5" max="8.0" step="0.1" value="3.0">
            </div>
            
             <div class="control-group">
                <label>Pair Separation (Inverse Distance) <span id="val-pair-sep">0.5</span></label>
                <input type="range" id="input-pair-sep" min="0.1" max="2.0" step="0.1" value="0.8">
            </div>
        </div>

        <div class="section">
            <h2>Topology Controls</h2>
            
            <div class="control-group">
                <label>Torus Radius (Major) <span id="val-separation">18.0</span></label>
                <input type="range" id="input-separation" min="10" max="40" step="0.1" value="25.0">
            </div>
            
             <div class="control-group">
                <label>Knot Height (Z-Scale) <span id="val-zscale">10.0</span></label>
                <input type="range" id="input-zscale" min="5" max="30" step="0.1" value="12.0">
            </div>
            
            <div class="control-group">
                <label>Flow Velocity <span id="val-speed">0.5</span></label>
                <input type="range" id="input-speed" min="0" max="2.0" step="0.01" value="0.2">
            </div>

            <label class="checkbox-wrapper">
                <input type="checkbox" id="check-lattice" checked onchange="toggleLattice(this.checked)">
                Show 4x4x4 Cubic Lattice
            </label>
        </div>

        <div class="section">
            <h2>Logic: Triple Trefoil Equilibrium</h2>
            <p>3 Interlaced Trefoils form a Clifford Torus skeleton. Each carries a data stream and its inverse.</p>
            
            <h3>Quaternion Rotation</h3>
            <p>Instead of linear matrices, position $P$ is rotated by quaternion $q$ derived from the Frenet frame:</p>
            <div class="math-block">
                $$ P' = q \cdot P \cdot q^{-1} $$
            </div>

            <h3>Emergent 4th Phase</h3>
            <p>The white core is the vector sum of the 3 pairs. In perfect equilibrium, it stabilizes at the singularity (Zero Point).</p>
            <div class="math-block">
                $$ \Psi_{4} = \sum_{k=1}^{3} (S_k + S_k^{-1}) $$
            </div>
        </div>

    </div>

    <script>
        // --- 1. Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        
        // Camera
        const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 2000);
        const initialCameraPos = { x: 0, y: 0, z: 120 }; 
        camera.position.set(initialCameraPos.x, initialCameraPos.y, initialCameraPos.z);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Orbit Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 0);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const pLight = new THREE.PointLight(0xffffff, 1.2);
        pLight.position.set(50, 50, 50);
        scene.add(pLight);
        const pLight2 = new THREE.PointLight(0x4a9eff, 0.8);
        pLight2.position.set(-50, -50, 50);
        scene.add(pLight2);
        
        // Lattice Group
        const latticeGroup = new THREE.Group();
        latticeGroup.visible = true; // Default On
        scene.add(latticeGroup);

        function createLattice() {
            const size = 80;
            const divisions = 4;
            const step = size / divisions;
            const offset = size / 2;
            
            const material = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.15 });
            const geometry = new THREE.BufferGeometry();
            const vertices = [];

            for (let i = 0; i <= divisions; i++) {
                for (let j = 0; j <= divisions; j++) {
                    const k = -offset + i * step;
                    const l = -offset + j * step;
                    vertices.push(k, -offset, l); vertices.push(k, offset, l);
                    vertices.push(-offset, k, l); vertices.push(offset, k, l);
                    vertices.push(l, k, -offset); vertices.push(l, k, offset);
                }
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            latticeGroup.add(new THREE.LineSegments(geometry, material));
            
            // Nodes
            const dotGeometry = new THREE.BufferGeometry();
            const dotVertices = [];
            for (let x = 0; x <= divisions; x++) {
                for (let y = 0; y <= divisions; y++) {
                    for (let z = 0; z <= divisions; z++) {
                        dotVertices.push(-offset + x * step, -offset + y * step, -offset + z * step);
                    }
                }
            }
            dotGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dotVertices, 3));
            const dotMaterial = new THREE.PointsMaterial({ color: 0x666666, size: 0.8, transparent:true, opacity:0.3 });
            latticeGroup.add(new THREE.Points(dotGeometry, dotMaterial));
        }
        createLattice();

        // --- 2. Triple Trefoil Geometry (Toroidal) ---

        // Returns point on a Toroidal Trefoil
        // R = Major Radius, r = Minor Radius
        // Phase Offset allows interleaving 3 knots
        function getTorusTrefoilPoint(t, R, zScale, phaseOffset) {
            // (p, q) = (2, 3) torus knot is a trefoil
            // Parametric: 
            // x = (R + cos(3t)) * cos(2t)
            // y = (R + cos(3t)) * sin(2t)
            // z = sin(3t)
            
            // Add phaseOffset to t inside the 3t term to rotate the knot along the torus tube
            // But to rotate the whole knot, we offset t in the 2t term.
            // Let's offset the 'u' and 'v' parameters.
            
            // t goes 0 to 2PI. 
            // We want 3 distinct knots.
            // Let's adjust the angle of the 'tube' position.
            
            // Correct approach for interlaced trefoils:
            // They are just rotated by 120 degrees (2PI/3) around the Z axis?
            // Yes, a (2,3) torus knot has 3-fold symmetry.
            // Wait, rotating a (2,3) knot by 120 deg maps it to itself.
            // We want 3 PARALLEL strands.
            // Like a 3-wire braid.
            // So we offset the angle INSIDE the tube (the 3t term).
            
            const minorR = 6.0; // Fixed minor radius for the knot structure itself
            const tubeAngle = 3 * t + phaseOffset; // Offset here separates the strands
            const torusAngle = 2 * t;
            
            const r = minorR * Math.cos(tubeAngle); // Radial component on tube
            const z = minorR * Math.sin(tubeAngle); // Z component on tube
            
            // Project to 3D
            // R is the major radius of the torus
            const x = (R + r) * Math.cos(torusAngle);
            const y = (R + r) * Math.sin(torusAngle);
            
            return new THREE.Vector3(x, y, z * (zScale/10.0));
        }

        function computeQuaternionFrame(t, R, zScale, phaseOffset) {
            const epsilon = 0.01;
            const p0 = getTorusTrefoilPoint(t, R, zScale, phaseOffset);
            const p1 = getTorusTrefoilPoint(t + epsilon, R, zScale, phaseOffset);
            
            // Tangent
            const T = new THREE.Vector3().subVectors(p1, p0).normalize();
            
            // Normal (Approximate)
            const p2 = getTorusTrefoilPoint(t + epsilon * 2, R, zScale, phaseOffset);
            const T2 = new THREE.Vector3().subVectors(p2, p1).normalize();
            const N = new THREE.Vector3().subVectors(T2, T).normalize();
            
            // Binormal
            const B = new THREE.Vector3().crossVectors(T, N).normalize();
            
            // Create Quaternion from Basis Matrix
            const m = new THREE.Matrix4();
            m.makeBasis(N, B, T);
            const q = new THREE.Quaternion();
            q.setFromRotationMatrix(m);
            
            return { p: p0, q: q };
        }

        class TwistorPair {
            constructor(color, phaseOffset, particleCount) {
                this.baseColor = color;
                this.phaseOffset = phaseOffset; // 0, 2PI/3, 4PI/3
                this.particleCount = particleCount;
                
                this.streamA = this.createStreamMesh();
                this.streamB = this.createStreamMesh();
                
                scene.add(this.streamA);
                scene.add(this.streamB);
                
                // For emergent calculation
                this.currentPositionsA = [];
                this.currentPositionsB = [];
            }

            createStreamMesh() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
                const material = new THREE.PointsMaterial({
                    color: this.baseColor,
                    size: 0.8,
                    map: sprite,
                    transparent: true,
                    opacity: 0.8,
                    alphaTest: 0.5
                });
                return new THREE.Points(geometry, material);
            }
            
            setHighlight(active) {
                const opacity = active ? 0.9 : 0.05;
                const size = active ? 0.9 : 0.4;
                this.streamA.material.opacity = opacity;
                this.streamB.material.opacity = opacity;
                this.streamA.material.size = size;
                this.streamB.material.size = size;
            }

            update(time, state) {
                const posA = this.streamA.geometry.attributes.position.array;
                const posB = this.streamB.geometry.attributes.position.array;
                
                this.currentPositionsA = [];
                this.currentPositionsB = [];
                
                for(let i=0; i<this.particleCount; i++) {
                    const tOffset = (i / this.particleCount) * Math.PI * 2;
                    const t = (tOffset + time * state.speed) % (Math.PI * 2);
                    
                    const frame = computeQuaternionFrame(t, state.phaseSep, state.zScale, this.phaseOffset);
                    
                    // --- Quaternion Physics ---
                    // 1. Expansion Vector (Buckle) in Local Space
                    // We define a vector pointing OUT from the tube center
                    const buckleRadius = state.buckle;
                    // Initial vector (e.g., along Normal)
                    const vLocal = new THREE.Vector3(buckleRadius, 0, 0);
                    
                    // 2. Micro-Twist Rotation
                    // Rotate this vector around the Tangent (Z-axis in local space)
                    const twistAngle = t * state.microTwist;
                    
                    // Doublet Separation (Inverse)
                    const sepAngle = state.pairSep * 0.5;
                    
                    // Stream A Rotation
                    const qTwistA = new THREE.Quaternion();
                    qTwistA.setFromAxisAngle(new THREE.Vector3(0, 0, 1), twistAngle + sepAngle); // Rotate around local Z (Tangent)
                    
                    // Stream B Rotation (Inverse/Opposite)
                    const qTwistB = new THREE.Quaternion();
                    qTwistB.setFromAxisAngle(new THREE.Vector3(0, 0, 1), twistAngle + Math.PI - sepAngle);
                    
                    // Apply Twist to Local Vector
                    const vA = vLocal.clone().applyQuaternion(qTwistA);
                    const vB = vLocal.clone().applyQuaternion(qTwistB);
                    
                    // 3. Transform Local to World
                    // Apply the Frame Quaternion (Orientation of the knot)
                    vA.applyQuaternion(frame.q);
                    vB.applyQuaternion(frame.q);
                    
                    // Add to Knot Position
                    const finalA = new THREE.Vector3().addVectors(frame.p, vA);
                    const finalB = new THREE.Vector3().addVectors(frame.p, vB);

                    posA[i*3] = finalA.x; posA[i*3+1] = finalA.y; posA[i*3+2] = finalA.z;
                    posB[i*3] = finalB.x; posB[i*3+1] = finalB.y; posB[i*3+2] = finalB.z;
                    
                    // Store for Emergent Phase calc
                    if(i % 10 === 0) { // Sample every 10th for performance
                        this.currentPositionsA.push(finalA);
                        this.currentPositionsB.push(finalB);
                    }
                }
                
                this.streamA.geometry.attributes.position.needsUpdate = true;
                this.streamB.geometry.attributes.position.needsUpdate = true;
            }
        }

        // --- 3. Emergent Phase 4 (The Core) ---
        class EmergentCore {
            constructor() {
                const geometry = new THREE.BufferGeometry();
                const count = 50; // Match sampled count
                const positions = new Float32Array(count * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');
                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2.0,
                    map: sprite,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                
                this.mesh = new THREE.Points(geometry, material);
                scene.add(this.mesh);
            }
            
            update(pairs) {
                const positions = this.mesh.geometry.attributes.position.array;
                const count = positions.length / 3;
                
                // Calculate centroid of all streams at each sampled index
                for(let i=0; i<count; i++) {
                    let sumX=0, sumY=0, sumZ=0;
                    let total = 0;
                    
                    pairs.forEach(pair => {
                        if(pair.currentPositionsA[i]) {
                            sumX += pair.currentPositionsA[i].x + pair.currentPositionsB[i].x;
                            sumY += pair.currentPositionsA[i].y + pair.currentPositionsB[i].y;
                            sumZ += pair.currentPositionsA[i].z + pair.currentPositionsB[i].z;
                            total += 2;
                        }
                    });
                    
                    if(total > 0) {
                        positions[i*3] = sumX / total;
                        positions[i*3+1] = sumY / total;
                        positions[i*3+2] = sumZ / total;
                    }
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
            
            setHighlight(active) {
                this.mesh.material.opacity = active ? 0.9 : 0.1;
                this.mesh.material.size = active ? 2.5 : 1.0;
            }
        }

        // --- 4. Instantiation ---

        // 3 Pairs on 3 Phase Offsets
        const pair1 = new TwistorPair(0xff0055, 0, 200);             // Alpha
        const pair2 = new TwistorPair(0x00f2ff, (Math.PI*2)/3, 200); // Beta
        const pair3 = new TwistorPair(0xffd700, (Math.PI*4)/3, 200); // Gamma
        
        const pairs = [pair1, pair2, pair3];
        const emergentCore = new EmergentCore();

        // --- 5. State & Controls ---

        const state = {
            microTwist: 2.5,
            buckle: 3.0,
            pairSep: 0.8,
            phaseSep: 25.0, // Major Radius R
            zScale: 12.0,
            speed: 0.2
        };
        
        let time = 0;

        function bind(id, key) {
            const el = document.getElementById(id);
            el.addEventListener('input', (e) => {
                state[key] = parseFloat(e.target.value);
                const label = document.getElementById(id.replace('input-', 'val-'));
                if(label) label.innerText = state[key].toFixed(1);
            });
        }

        bind('input-twist', 'microTwist');
        bind('input-buckle', 'buckle');
        bind('input-pair-sep', 'pairSep');
        bind('input-separation', 'phaseSep');
        bind('input-zscale', 'zScale');
        bind('input-speed', 'speed');

        window.resetCamera = function() {
            camera.position.set(initialCameraPos.x, initialCameraPos.y, initialCameraPos.z);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        };

        window.toggleLattice = function(checked) {
            latticeGroup.visible = checked;
        };

        window.highlightPhase = function(index) {
            // 0,1,2 = Pairs. 3 = Core. -1 = All
            if (index === 3) {
                pairs.forEach(p => p.setHighlight(false));
                emergentCore.setHighlight(true);
            } else {
                pairs.forEach((p, i) => {
                    if (index === -1) p.setHighlight(true);
                    else p.setHighlight(i === index);
                });
                emergentCore.setHighlight(index === -1);
            }
            
            const ids = ['phase-alpha', 'phase-beta', 'phase-gamma', 'phase-delta'];
            ids.forEach((id, i) => {
                const el = document.getElementById(id);
                if (index === -1) el.classList.remove('active');
                else {
                    if (i === index) el.classList.add('active');
                    else el.classList.remove('active');
                }
            });
        };

        // --- 6. Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);
            time += 0.05;
            
            pairs.forEach(p => p.update(time, state));
            emergentCore.update(pairs);
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();

    </script>
</body>
</html>
