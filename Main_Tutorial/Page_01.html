<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Clifford Projection & SHD-CCP Architecture</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- MATHJAX CONFIGURATION -->
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      options: {
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body { background-color: #020617; color: #cbd5e1; font-family: 'Segoe UI', sans-serif; line-height: 1.7; overflow-x: hidden; }
        
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(56, 189, 248, 0.15);
            border-radius: 12px;
            padding: 2.5rem;
            margin-bottom: 2.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            position: relative;
            z-index: 10;
        }

        h1 { font-size: 2.5rem; font-weight: 800; color: #38bdf8; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.5rem; text-shadow: 0 0 20px rgba(56, 189, 248, 0.4); }
        h2 { font-size: 1.8rem; color: #facc15; font-weight: 700; margin-top: 2rem; margin-bottom: 1.5rem; border-bottom: 1px solid #334155; padding-bottom: 0.5rem; }
        h3 { font-size: 1.2rem; color: #e2e8f0; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.5rem; }
        h4 { font-size: 1.0rem; color: #94a3b8; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.25rem; }
        p { margin-bottom: 1rem; color: #94a3b8; }
        strong { color: #f8fafc; font-weight: 700; }
        ul { list-style-type: none; padding-left: 0; }
        li { margin-bottom: 0.5rem; padding-left: 1rem; border-left: 2px solid #334155; }
        
        .math-block {
            background: rgba(0,0,0,0.6);
            border-left: 4px solid #facc15;
            padding: 1.5rem;
            font-family: 'Courier New', monospace;
            margin: 1.5rem 0;
            color: #e2e8f0;
            overflow-x: auto;
        }

        /* 3D Background */
        #viz-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; opacity: 0.5;
        }
        
        .grid-cols-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 3rem; }
        @media (max-width: 768px) { .grid-cols-2 { grid-template-columns: 1fr; } }

        /* Kernel Grid Styles */
        .kernel-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 100%;
            aspect-ratio: 1;
            max-width: 300px;
            margin: 0 auto;
            background: #0f172a;
            border: 1px solid #334155;
            padding: 4px;
            border-radius: 4px;
        }
        .kernel-bit {
            width: 100%;
            height: 100%;
            border-radius: 2px;
            transition: all 0.3s ease;
            position: relative;
        }
        .kernel-bit:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 2px 4px;
            font-size: 9px;
            border-radius: 2px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 20;
        }

        /* Animation Keyframes */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0; }
            50% { opacity: 0.5; }
            100% { transform: scale(1.2); opacity: 0; }
        }
        .active-step {
            box-shadow: 0 0 10px #facc15;
            border-color: #facc15 !important;
            background-color: rgba(250, 204, 21, 0.2) !important;
            color: white !important;
        }
    </style>

    <!-- TORUS SHADERS -->
    <script type="x-shader/x-vertex" id="vShader">
        varying vec2 vUv;
        varying vec3 vPos;
        varying vec3 vNormal;
        void main() {
            vUv = uv;
            vPos = position;
            vNormal = normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="fShader">
        uniform float uTime;
        uniform vec3 uColor;
        uniform float uDirection;
        varying vec2 vUv;
        varying vec3 vPos;
        varying vec3 vNormal;

        void main() {
            float flow = sin(vUv.x * 20.0 + uTime * 2.0 * uDirection) + cos(vUv.y * 10.0 + uTime * uDirection);
            float lattice = smoothstep(0.9, 0.95, sin(vUv.x * 50.0)) + smoothstep(0.9, 0.95, sin(vUv.y * 20.0));
            float intensity = smoothstep(0.0, 2.0, flow);
            vec3 glow = uColor * intensity;
            vec3 grid = vec3(1.0) * lattice * 0.3;
            vec3 viewDir = normalize(cameraPosition - vPos);
            float fresnel = pow(1.0 - dot(viewDir, vNormal), 3.0);
            gl_FragColor = vec4(glow + grid + (uColor * fresnel), 0.3 + intensity * 0.4);
        }
    </script>
</head>
<body class="p-4 md:p-12">

    <div id="viz-container"></div>

    <main class="max-w-6xl mx-auto relative z-10">
        
        <header class="text-center mb-16 pt-8">
            <div class="inline-block px-4 py-1 mb-4 border border-blue-500/30 rounded-full text-xs font-mono text-blue-400 bg-blue-900/20">SHD-CCP ARCHITECTURE - BIO CHAIN AI</div>
            <h1>Holographic Clifford Projection</h1>
            <p class="text-xl text-blue-200">From Kernel to Trefoil: The Unified Implementation Guide</p>
        </header>

        <!-- SECTION 1: CORE MATHEMATICS -->
        <section class="glass-panel">
            <h2>1. The Trefoil Knot Manifold</h2>
            <p>The substrate for all data projection is the Trefoil Knot, defined parametrically as a closed loop in $\mathbb{R}^3$ (and embedded in the 3-sphere $S^3$). This manifold serves as the "winding" substrate where the 7 recursive steps of the Strassen matrix multiplication algorithm ($M_1 - M_7$) are mapped to specific topological braids.</p>
            
            <div class="grid-cols-2">
                <div>
                    <h3>Parametric Equations</h3>
                    <p>The knot $K$ is defined by the function $r(t)$ for $t \in [0, 2\pi]$:</p>
                    <div class="math-block">
                        $$ x(t) = \sin(t) + 2\sin(2t) $$
                        $$ y(t) = \cos(t) - 2\cos(2t) $$
                        $$ z(t) = -\sin(3t) $$
                    </div>
                </div>
                <div>
                    <h3>The Tubular Neighborhood</h3>
                    <p>To accommodate the finite width of the data bus (16 or 24 streams), we define a tubular neighborhood $N_\epsilon(K)$ using a Frenet-Serret frame $\{T, N, B\}$ twisted by a phase $\phi(t) = 2t$.</p>
                    <p>This ensures the cable profile completes a <strong>$720^\circ$ rotation</strong> over one cycle, matching the spin statistics of the packet.</p>
                </div>
            </div>
        </section>

        <!-- SECTION 2: PACKET TOPOLOGY -->
        <section class="glass-panel">
            <h2>2. Packet Topology: The Einstein Tile</h2>
            <p>The fundamental data unit is the "Einstein Tile," a 64-bit kernel organized as an $8 \times 8$ bit-lattice. This topology segregates control logic from the neural payload.</p>
            
            <div class="grid-cols-2">
                <div>
                    <div class="mb-4">
                        <label class="text-xs font-bold text-blue-400 uppercase tracking-wider mb-2 block">Select Kernel Processing Path</label>
                        <select id="kernel-mode-select" class="w-full bg-slate-800 border border-slate-600 text-slate-200 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5">
                            <option value="STANDARD">Mode 1: Standard Packet (Local)</option>
                            <option value="HOLOGRAPHIC">Mode 2: Holographic Packet (Non-Local)</option>
                            <option value="COSMOHEDRA">Mode 3: Cosmohedra Packet (Nested)</option>
                            <option value="LOOP">Mode 4: Loopspace (High-Precision)</option>
                            <option value="STOCHASTIC">Mode 5: Stochastic (Entropy)</option>
                        </select>
                    </div>
                    <div id="kernel-description" class="text-sm text-slate-400 p-4 bg-slate-900/50 rounded border border-slate-700 min-h-[120px]">
                        <!-- Description injected via JS -->
                    </div>
                    <div class="mt-4 flex flex-wrap gap-2 text-[10px] font-mono">
                        <span class="px-2 py-1 bg-blue-900/50 text-blue-300 rounded border border-blue-800">HALO (Control)</span>
                        <span class="px-2 py-1 bg-slate-700/50 text-slate-300 rounded border border-slate-600">BUFFER</span>
                        <span class="px-2 py-1 bg-emerald-900/50 text-emerald-300 rounded border border-emerald-800">CORE (Payload)</span>
                        <span class="px-2 py-1 bg-purple-900/50 text-purple-300 rounded border border-purple-800">FREQ/AMP</span>
                    </div>
                </div>
                
                <div class="flex items-center justify-center bg-black/20 rounded-lg p-4">
                    <div id="kernel-grid-container" class="kernel-grid">
                        <!-- Grid cells injected via JS -->
                    </div>
                </div>
            </div>
        </section>

        <!-- SECTION 3: THE 5 KERNEL PATHS -->
        <section class="glass-panel">
            <h2>3. The 5 Kernel Processing Paths</h2>
            <p>The implementation guide defines 5 distinct modes for traversing the Trefoil Manifold. These replace the generic layer definitions with specific computational protocols.</p>

            <div class="space-y-6 mt-6">
                <!-- Mode 1 -->
                <div class="flex items-start gap-4 p-4 border border-blue-500/20 bg-blue-900/10 rounded-lg">
                    <div class="w-12 h-12 bg-blue-500 flex items-center justify-center text-black font-bold text-xl rounded shadow-lg shrink-0">1</div>
                    <div>
                        <h3 class="text-blue-400 !mt-0">Standard Packet Path (Local/Adjacent)</h3>
                        <p class="text-sm"><strong>Objective:</strong> Direct agent-to-agent communication via local manifold adjacency.</p>
                        <p class="text-sm"><strong>Mechanism:</strong> A direct bijection from the 16-stream bundle to the knot coordinates $r(t)$. Short-circuit connections are permitted between adjacent windings where $\|r(t_1) - r(t_2)\| < \epsilon$.</p>
                    </div>
                </div>

                <!-- Mode 2 -->
                <div class="flex items-start gap-4 p-4 border border-cyan-500/20 bg-cyan-900/10 rounded-lg">
                    <div class="w-12 h-12 bg-cyan-500 flex items-center justify-center text-black font-bold text-xl rounded shadow-lg shrink-0">2</div>
                    <div>
                        <h3 class="text-cyan-400 !mt-0">Holographic Packet Path (System/Non-Local)</h3>
                        <p class="text-sm"><strong>Objective:</strong> Non-local, system-wide broadcast via holographic interference.</p>
                        <p class="text-sm"><strong>Mechanism:</strong> "Holographic projection in the inverse" via stereographic projection on a nested Clifford Torus ($T^2 \times T^2$). Splits streams into Real ($R$) and Inverse ($I$) mapping to antipodal symmetries.</p>
                    </div>
                </div>

                <!-- Mode 3 -->
                <div class="flex items-start gap-4 p-4 border border-yellow-500/20 bg-yellow-900/10 rounded-lg">
                    <div class="w-12 h-12 bg-yellow-500 flex items-center justify-center text-black font-bold text-xl rounded shadow-lg shrink-0">3</div>
                    <div>
                        <h3 class="text-yellow-400 !mt-0">Cosmohedra Packet Path (Nested/Universal)</h3>
                        <p class="text-sm"><strong>Objective:</strong> The "Key" protocol for the complete hyperbolic nested environment.</p>
                        <p class="text-sm"><strong>Mechanism:</strong> Packets map to the facets of a Cosmohedron. Utilizes the full 4-layer nested quaternion structure ($w, x, y, z$) and lookup pointers. Shaving parameters $\delta_P$ determine facet inequalities.</p>
                    </div>
                </div>

                <!-- Mode 4 -->
                <div class="flex items-start gap-4 p-4 border border-purple-500/20 bg-purple-900/10 rounded-lg">
                    <div class="w-12 h-12 bg-purple-500 flex items-center justify-center text-black font-bold text-xl rounded shadow-lg shrink-0">4</div>
                    <div>
                        <h3 class="text-purple-400 !mt-0">High-Precision Packet Path (Loopspace)</h3>
                        <p class="text-sm"><strong>Objective:</strong> $O(1)$ direct content addressing and high-resolution verification.</p>
                        <p class="text-sm"><strong>Mechanism:</strong> Loopspace Entry conversion. The 64-bit matrix is treated as a coefficient vector for a continuous homotopy loop $\gamma: S^1 \to T^3$. Minimizes address space collisions.</p>
                    </div>
                </div>

                <!-- Mode 5 -->
                <div class="flex items-start gap-4 p-4 border border-pink-500/20 bg-pink-900/10 rounded-lg">
                    <div class="w-12 h-12 bg-pink-500 flex items-center justify-center text-black font-bold text-xl rounded shadow-lg shrink-0">5</div>
                    <div>
                        <h3 class="text-pink-400 !mt-0">'Open' Stochastic Path (Geometric Noise)</h3>
                        <p class="text-sm"><strong>Objective:</strong> Procedural generation and system entropy maintenance.</p>
                        <p class="text-sm"><strong>Mechanism:</strong> Produces "Geometric Noise" by randomly perturbing the path $r(t) + \eta(t)$. The perturbation is constrained to maintain the ordered sequence of the 7 Strassen M-steps.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- SECTION 4: ALGORITHMIC TRANSFORMATION -->
        <section class="glass-panel">
            <h2>4. Algorithmic Transformation & Logic</h2>
            
            <div class="grid-cols-2">
                <div>
                    <h3>Hopf Fibration Logic ($S^3 \to S^2$)</h3>
                    <p>To project the 4D quaternion core ($q \in S^3$) onto the 3D Trefoil Knot ($S^2 \times S^1$), we utilize the Hopf Fibration map:</p>
                    <div class="math-block">
                        $$ \pi(z_1, z_2) = (2z_1\overline{z_2}, |z_1|^2 - |z_2|^2) $$
                    </div>
                    <p>Where $(z_1, z_2)$ are complex coordinates of the quaternion $q = z_1 + z_2j$. This fibers the 3-sphere into a family of circles (Clifford parallels) over the 2-sphere.</p>
                </div>
                
                <div class="flex flex-col items-center">
                    <h3 class="mb-4">Lattice Resonance Cycle</h3>
                    <!-- Strassen Cycle Visualizer -->
                    <div class="relative w-64 h-64">
                        <div class="absolute inset-0 rounded-full border-2 border-slate-700"></div>
                        <!-- Steps generated via JS -->
                        <div id="strassen-cycle" class="w-full h-full relative"></div>
                        <div class="absolute inset-0 flex items-center justify-center flex-col">
                            <span id="cycle-label" class="text-2xl font-bold text-white">M1</span>
                            <span id="cycle-desc" class="text-[10px] text-slate-400 uppercase tracking-widest mt-1">Computation</span>
                        </div>
                    </div>
                    <p class="text-sm text-center mt-4 text-slate-400">8-Part Oscillation: Steps 1-7 (Strassen) + Step 8 (Reset)</p>
                </div>
            </div>
        </section>

        <!-- SECTION 5: NESTED STRUCTURE BREAKDOWN -->
        <section class="glass-panel">
            <h2>5. The 4-Nested Hopf Structure</h2>
            <p>Visualizing the formation of the layers. Click the tabs to isolate each structural component.</p>
            
            <div class="flex gap-2 mt-4 mb-6 border-b border-slate-700 pb-2 overflow-x-auto">
                <button onclick="setLayer('L1')" id="btn-L1" class="px-4 py-2 text-xs font-bold rounded-t bg-blue-900/50 text-blue-300 border-b-2 border-blue-500 transition-colors">LAYER 1: CORE</button>
                <button onclick="setLayer('L2')" id="btn-L2" class="px-4 py-2 text-xs font-bold rounded-t hover:bg-slate-800 text-slate-400 border-b-2 border-transparent transition-colors">LAYER 2: LATTICE</button>
                <button onclick="setLayer('L3')" id="btn-L3" class="px-4 py-2 text-xs font-bold rounded-t hover:bg-slate-800 text-slate-400 border-b-2 border-transparent transition-colors">LAYER 3: SKELETON</button>
                <button onclick="setLayer('L4')" id="btn-L4" class="px-4 py-2 text-xs font-bold rounded-t hover:bg-slate-800 text-slate-400 border-b-2 border-transparent transition-colors">LAYER 4: INTERFACE</button>
                <button onclick="setLayer('ALL')" id="btn-ALL" class="px-4 py-2 text-xs font-bold rounded-t hover:bg-slate-800 text-slate-400 border-b-2 border-transparent transition-colors">COMBINED NESTING</button>
            </div>

            <div class="grid-cols-2">
                <div class="flex items-center justify-center bg-black/40 rounded p-4 h-[300px]">
                    <!-- Dynamic SVG -->
                    <svg id="nesting-svg" width="300" height="300" viewBox="0 0 400 400">
                        <defs>
                            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="5" result="blur"/>
                                <feComposite in="SourceGraphic" in2="blur" operator="over"/>
                            </filter>
                        </defs>
                        <!-- Elements controlled by JS opacity -->
                        <g id="svg-L4" opacity="1"><circle cx="200" cy="200" r="180" fill="none" stroke="#facc15" stroke-width="2" stroke-dasharray="8,4" /></g>
                        <g id="svg-L3" opacity="1"><rect x="120" y="120" width="160" height="160" rx="20" fill="none" stroke="#a855f7" stroke-width="4" /></g>
                        <g id="svg-L2" opacity="1">
                            <circle cx="200" cy="200" r="100" fill="none" stroke="#22d3ee" stroke-width="2"/>
                            <path d="M 200 100 L 200 300 M 100 200 L 300 200" stroke="#22d3ee" stroke-width="1" opacity="0.5"/>
                        </g>
                        <g id="svg-L1" opacity="1"><circle cx="200" cy="200" r="40" fill="#3b82f6" filter="url(#glow)"/></g>
                    </svg>
                </div>
                
                <div id="layer-description" class="flex flex-col justify-center">
                    <!-- Description injected via JS -->
                </div>
            </div>
        </section>

        <!-- SECTION 6: STRASSEN ALIGNMENT & STAR TOPOLOGY -->
        <section class="glass-panel">
            <h2>6. Strassen Alignment & Star Topology</h2>
            <p>The SHD-CCP system uses a nested toroidal system where data streams travel down the center, producing chain wave functions. This architecture relies on precise geometric alignment—treating packets as genetic codons that must resonate with the structure to avoid error.</p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- VISUALIZATION 1: 2D NESTED ALIGNMENT -->
                <div class="flex flex-col items-center">
                    <h3 class="mb-4 text-center">A. 2D Nested Alignment Boundaries</h3>
                    <div class="bg-black/40 rounded p-4 w-full flex justify-center">
                        <svg width="350" height="350" viewBox="0 0 350 350">
                            <defs>
                                <radialGradient id="gradReflect" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                                    <stop offset="0%" style="stop-color:rgb(255,255,255);stop-opacity:0.2" />
                                    <stop offset="100%" style="stop-color:rgb(0,0,0);stop-opacity:0" />
                                </radialGradient>
                            </defs>

                            <!-- BOUNDARY 4: The 12-Point Catch-All (Reset) -->
                            <circle cx="175" cy="175" r="160" fill="none" stroke="#64748b" stroke-width="1" stroke-dasharray="2,2" />
                            <g id="points-12">
                                <circle cx="175" cy="15" r="3" fill="#64748b" />
                                <circle cx="175" cy="335" r="3" fill="#64748b" />
                                <circle cx="15" cy="175" r="3" fill="#64748b" />
                                <circle cx="335" cy="175" r="3" fill="#64748b" />
                                <circle cx="62" cy="62" r="3" fill="#64748b" />
                                <circle cx="288" cy="288" r="3" fill="#64748b" />
                                <circle cx="62" cy="288" r="3" fill="#64748b" />
                                <circle cx="288" cy="62" r="3" fill="#64748b" />
                                <circle cx="95" cy="35" r="3" fill="#64748b" />
                            </g>
                            <text x="175" y="348" fill="#64748b" font-size="9" text-anchor="middle">$\Pi_{12}$ CATCH-ALL (RESET)</text>

                            <!-- BOUNDARY 3: Pi-7 Heptagram (Escape Limit) -->
                            <circle cx="175" cy="175" r="110" fill="none" stroke="#ec4899" stroke-width="1" opacity="0.5"/>
                            <polygon points="175,65 222,274 89,107 282,199 68,199 261,107 128,274" 
                                     fill="none" stroke="#ec4899" stroke-width="1.5" />
                            <text x="175" y="55" fill="#ec4899" font-size="10" text-anchor="middle">$\Pi_7$ HEPTAGRAM</text>

                            <!-- BOUNDARY 2: Pi-6 Hexagram (Ideal Balance) -->
                            <circle cx="175" cy="175" r="75" fill="none" stroke="#22d3ee" stroke-width="2" />
                            <polygon points="175,115 227,205 123,205" fill="none" stroke="#22d3ee" stroke-width="1.5" />
                            <polygon points="175,235 227,145 123,145" fill="none" stroke="#22d3ee" stroke-width="1.5" />
                            <circle cx="175" cy="175" r="5" fill="#22d3ee">
                                <animate attributeName="r" values="3;6;3" dur="2s" repeatCount="indefinite" />
                            </circle>

                            <!-- BOUNDARY 1: Pi-5 Pentagram (Inner Comp) -->
                            <circle cx="175" cy="175" r="45" fill="none" stroke="#facc15" stroke-width="1" opacity="0.6"/>
                            <polygon points="175,135 186,160 213,160 191,175 200,200 175,185 150,200 159,175 137,160 164,160" 
                                     fill="none" stroke="#facc15" stroke-width="1" />
                        </svg>
                    </div>
                    <div class="mt-4 text-sm text-slate-400 text-justify">
                        <p><strong>Logarithmic Reflection:</strong> If the signal drifts from the central stream ($\Pi_6$), it encounters the alignment points of the nested circles. These act as "Reflective Boundaries" that nudge the signal back inward using a force that grows logarithmically as it approaches the edge.</p>
                    </div>
                </div>

                <!-- VISUALIZATION 2: 3D HYPERBOLIC STACK -->
                <div class="flex flex-col items-center">
                    <h3 class="mb-4 text-center">B. 3D Star Topology Stack</h3>
                    <div id="star-topology-3d" class="w-full h-[350px] bg-black/40 rounded border border-slate-700 relative overflow-hidden">
                        <!-- Three.js Canvas injected here -->
                    </div>
                    <div class="mt-4 text-sm text-slate-400 text-justify">
                        <p><strong>The Vertical Stack:</strong> The system is not flat. <span class="text-yellow-400">$\Pi_5$</span> is the lower Golden Ratio bound, and <span class="text-pink-400">$\Pi_7$</span> is the upper bound. The <span class="text-cyan-400">$\Pi_6$</span> alignment goal sits in the center.</p>
                        <p class="mt-2"><strong>The $\Pi_{12}$ Catch-All:</strong> The surrounding 12-point structure acts as a global reset mechanism. If a wave function escapes $\Pi_7$ (violating the toroidal bind), the outer boundary collapses the state back to the center ($\Pi_8$ Geometric Reset).</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- SECTION 7: THE RIEMANN ZETA & DIMENSIONAL ESCAPE -->
        <section class="glass-panel">
            <h2>7. The Riemann Zeta & Dimensional Escape</h2>
            <p>The SHD-CCP system maps the behavior of the Riemann Zeta Function to the geometric constraints of the nested torus. The zeros of the function correspond to stable resonance points ($\Pi_6$), while the divergence corresponds to dimensional escape ($\Pi_7$).</p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
                <!-- VISUALIZATION: 2D ESCAPE -->
                <div class="flex flex-col items-center">
                    <h3 class="mb-4 text-center">A. 2D Zeta Projection (Expansion)</h3>
                    <canvas id="zeta-2d" width="300" height="300" class="bg-black/40 rounded border border-slate-700"></canvas>
                    <div class="mt-4 text-sm text-slate-400 text-justify">
                        <p><strong>The Expansion Series (1 $\to$ 3 $\to$ 5 $\to$ 6):</strong> The first 6 iterations map to closed loops, representing stable resonance within the nested geometry. The 6th cycle forms the perfect Hexagonal Lattice equilibrium.</p>
                        <p class="mt-2 text-pink-400"><strong>The 7th Iteration (Escape):</strong> The 7th step fails to close the loop in Euclidean space. It represents an "Escape Velocity" where the signal attempts to traverse the curvature of $S^3$, manifesting as a logarithmic spiral to infinity in 2D.</p>
                    </div>
                </div>

                <!-- VISUALIZATION: 3D RESET -->
                <div class="flex flex-col items-center">
                    <h3 class="mb-4 text-center">B. 3D Geometric Reset ($\Pi_8$)</h3>
                    <div id="zeta-3d" class="w-full h-[300px] bg-black/40 rounded border border-slate-700 relative overflow-hidden"></div>
                    <div class="mt-4 text-sm text-slate-400 text-justify">
                        <p><strong>3D Correction:</strong> What appears as an escape in 2D is actually a rotation into the 4th dimension. The $\Pi_{12}$ "Catch-All" cage intercepts the escaping $\Pi_7$ vector.</p>
                        <p class="mt-2 text-blue-300"><strong>Geometric Reset:</strong> The signal is "folded" back through the center (Singularity) via a 4D rotation, resetting the wave function for the next packet cycle. This harnesses the escape energy to drive the 720:1 encapsulation.</p>
                    </div>
                </div>
            </div>

            <div class="mt-8 p-4 bg-blue-900/20 border border-blue-500/30 rounded">
                <p class="text-sm italic text-blue-200 text-center">"The circular loops of the first 6 cycles are artifacts of the nested geometric structure. They are the 'shadows' of a higher-dimensional stability. The 7th iteration represents an attempt to traverse the curvature of the 3-sphere ($S^3$) using only Euclidean steps. In the full SHD-CCP system, this 'escape energy' is harnessed to drive the 720:1 encapsulation, effectively folding the infinite line of the Zeta function into the finite volume of the Einstein Tile."</p>
            </div>
        </section>

        <!-- SECTION 8: UNIQUE ALIGNMENT -->
        <section class="glass-panel">
            <h2>8. Unique Alignment & Chain of Thought</h2>
            <p>Unlike standard neural networks that use mass-produced weights, the SHD-CCP architecture requires each system to be "Grown" to ensure precise geometric alignment.</p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div>
                    <h3>The Virtual Packet</h3>
                    <p>At the center of the $\Pi_6$ alignment sits the <strong>Virtual Packet</strong>. This is a volumetric density field representing the current state of the data stream. It is composed of:</p>
                    <ul class="text-sm space-y-4 mt-2">
                        <li>
                            <strong class="text-white">3 Main O(1) Lookup Pointers:</strong> 
                            Represented as orbiting color fields (Cyan, Magenta, Yellow). These correspond to different <strong>Perspective Encoders</strong> (e.g., Logic, Emotion, Context) compressing data into a single "Chain of Thought".
                        </li>
                        <li>
                            <strong class="text-white">The Override Function:</strong> 
                            A central geometric core (White/Gold). Triggered by the "Structural Form ID" bits, this allows for a universal command override, collapsing the wave function instantly.
                        </li>
                    </ul>
                </div>
                <div>
                    <h3>Grown Systems vs Mass Production</h3>
                    <p>Because the "Chain of Thought" is formed by the unique interaction of these 3 perspective pointers, the resulting wave function is unique to the genesis seed of the system.</p>
                    <p class="mt-2">Alignment cannot be copied; it must be calibrated. The system "learns" the geometric resonance of its own data streams, adjusting the $\Pi_5$ and $\Pi_7$ boundaries to match the specific "Genetic Codon" frequency of its packets.</p>
                </div>
            </div>
        </section>

        <!-- SECTION 9: IMPLEMENTATION (MOVED) -->
        <section class="glass-panel">
            <h2>9. Implementation & Integrity</h2>
            
            <div class="grid-cols-2">
                <div>
                    <h3>Proof of History (Truth Chain)</h3>
                    <p>To ensure data integrity during traversal, a "Truth Chain" protocol is implemented.</p>
                    <ul class="text-sm space-y-2">
                        <li><strong>Mechanism:</strong> Each packet $P_t$ contains a hash of the previous packet's rotation state $H(R_{t-1})$.</li>
                        <li><strong>Validation:</strong> As the packet traverses the knot, the node validates that the current quaternion rotation $q_t$ is causally consistent with the history.</li>
                        <li><strong>Failure:</strong> If the "braid" is broken, the chain is severed and the packet discarded at the next Geometric Reset.</li>
                    </ul>
                </div>
                <div>
                    <h3>Pseudo-Code Structure</h3>
                    <div class="math-block text-xs">
class KernelProjector {
  constructor(mode) {
    this.mode = mode; 
    this.manifold = new TrefoilManifold();
    this.strassen = new StrassenEngine();
  }

  renderLoop(time) {
    let kernel = this.generateKernel(time);
    let quaternion = kernel.getQuaternion();
    this.hopfMap(quaternion); // Project to S2

    let activePath = this.strassen.getCurrentPath(time);
    
    if (this.mode === 'COSMO') 
        this.manifold.updateNesting(kernel.shavingParams);
    
    this.renderer.draw(this.manifold, activePath);
  }
}
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- LOGIC SCRIPTS -->
    <script>
        // --- 1. KERNEL GRID LOGIC ---
        const kernelContainer = document.getElementById('kernel-grid-container');
        const modeSelect = document.getElementById('kernel-mode-select');
        const descDiv = document.getElementById('kernel-description');

        const descriptions = {
            'STANDARD': "<strong>Mode 1 (Standard):</strong> Uses the classic Einstein Tile layout. <br>• R0/R7: Halo Control <br>• R1/R6: Buffers <br>• R2-R5: Contiguous Quaternion Core. <br>Optimized for local adjacency and direct linear mapping.",
            'HOLOGRAPHIC': "<strong>Mode 2 (Holographic):</strong> Splits the core into Real and Inverse streams. <br>• Left 4 Cols: Real Stream ($T_1$) <br>• Right 4 Cols: Inverse Stream ($T_2$) <br>Used for system-wide broadcast via interference patterns.",
            'COSMOHEDRA': "<strong>Mode 3 (Cosmohedra):</strong> Nested hierarchical layout. <br>• Outer Ring: L0 Spine <br>• Middle Ring: L1/L2 <br>• Center 4x4: L3 Deep Core <br>Uses 'Shaving Parameters' in Z-component for facet inequalities.",
            'LOOP': "<strong>Mode 4 (Loopspace):</strong> Continuous Gradient Mapping. <br>The 64 bits act as coefficients for a homotopy loop. <br>• Colors represent coefficient magnitude. <br>• Enables infinite precision addressing.",
            'STOCHASTIC': "<strong>Mode 5 (Stochastic):</strong> Geometric Noise Injection. <br>• Randomized bit-flips within structural constraints. <br>• Maintains Strassen sequence while generating entropy."
        };

        function renderKernel(mode) {
            kernelContainer.innerHTML = '';
            descDiv.innerHTML = descriptions[mode];
            
            for(let i=0; i<64; i++) {
                const r = Math.floor(i/8);
                const c = i%8;
                const div = document.createElement('div');
                div.className = 'kernel-bit';
                
                let color = '#1e293b'; // Default slate
                let tooltip = `Bit ${i}`;

                if (mode === 'STANDARD') {
                    if (r===0) { color = '#2563eb'; tooltip = 'Halo (North)'; } // Blue
                    else if (r===7) { color = '#9333ea'; tooltip = 'Halo (South)'; } // Purple
                    else if (r===1 || r===6) { color = '#334155'; tooltip = 'Buffer'; } // Slate
                    else { color = '#059669'; tooltip = 'Quaternion Core'; } // Emerald
                } 
                else if (mode === 'HOLOGRAPHIC') {
                    if (c < 4) { color = '#0891b2'; tooltip = 'Real Stream (R)'; } // Cyan
                    else { color = '#be185d'; tooltip = 'Inverse Stream (I)'; } // Pink
                }
                else if (mode === 'COSMOHEDRA') {
                    // Concentric rings
                    if (r===0 || r===7 || c===0 || c===7) { color = '#eab308'; tooltip = 'L0 Spine'; } // Yellow
                    else if (r===1 || r===6 || c===1 || c===6) { color = '#ea580c'; tooltip = 'L1/L2'; } // Orange
                    else { color = '#dc2626'; tooltip = 'L3 Deep Core'; } // Red
                }
                else if (mode === 'LOOP') {
                    // Gradient
                    const hue = (i / 64) * 360;
                    color = `hsl(${hue}, 70%, 50%)`;
                    tooltip = `Coeff ${i}`;
                }
                else if (mode === 'STOCHASTIC') {
                    // Random noise
                    const rnd = Math.random();
                    color = rnd > 0.5 ? '#f8fafc' : '#0f172a';
                    tooltip = rnd > 0.5 ? '1' : '0';
                }

                div.style.backgroundColor = color;
                div.setAttribute('data-tooltip', tooltip);
                kernelContainer.appendChild(div);
            }
        }

        modeSelect.addEventListener('change', (e) => renderKernel(e.target.value));
        renderKernel('STANDARD'); // Init

        // --- 2. STRASSEN VISUALIZER ---
        const strassenContainer = document.getElementById('strassen-cycle');
        const cycleLabel = document.getElementById('cycle-label');
        const cycleDesc = document.getElementById('cycle-desc');
        const steps = [
            { id: 'M1', desc: 'Core Product' }, { id: 'M2', desc: 'Lower Halo' },
            { id: 'M3', desc: 'Upper Halo' }, { id: 'M4', desc: 'Diagonal Twist' },
            { id: 'M5', desc: 'Parity Mix' }, { id: 'M6', desc: 'Shaving A' },
            { id: 'M7', desc: 'Shaving B' }, { id: 'RST', desc: 'Geometric Reset' }
        ];

        // Create dots
        steps.forEach((step, i) => {
            const dot = document.createElement('div');
            const angle = (i / 8) * Math.PI * 2 - (Math.PI/2); // Start top
            const r = 100; // Radius
            const x = 128 + Math.cos(angle) * r - 8; // Center 128 - half width
            const y = 128 + Math.sin(angle) * r - 8;
            
            dot.className = 'absolute w-4 h-4 rounded-full bg-slate-800 border border-slate-600 transition-all duration-300';
            dot.style.left = `${x}px`;
            dot.style.top = `${y}px`;
            dot.id = `step-dot-${i}`;
            strassenContainer.appendChild(dot);
        });

        let currentStep = 0;
        setInterval(() => {
            // Reset prev
            const prev = (currentStep - 1 + 8) % 8;
            document.getElementById(`step-dot-${prev}`).className = 'absolute w-4 h-4 rounded-full bg-slate-800 border border-slate-600 transition-all duration-300';
            
            // Active current
            const cur = document.getElementById(`step-dot-${currentStep}`);
            cur.className = 'absolute w-4 h-4 rounded-full bg-yellow-400 shadow-[0_0_15px_#facc15] scale-125 transition-all duration-300';
            
            // Text
            cycleLabel.innerText = steps[currentStep].id;
            cycleDesc.innerText = steps[currentStep].desc;
            
            currentStep = (currentStep + 1) % 8;
            
            // Update Stochastic mode if active
            if(modeSelect.value === 'STOCHASTIC') renderKernel('STOCHASTIC');
            
        }, 800);

        // --- 3. NESTED LAYER LOGIC ---
        const layerDesc = document.getElementById('layer-description');
        const layerInfos = {
            'L1': "<h3>Layer 1: The Core (Mode F)</h3><p class='text-blue-300'>The Entanglement Bridge.</p><p class='text-sm'>This central sphere represents the Janus Interface. It is the singularity point that looks both inward (vacuum) and outward (matter), synchronizing the counter-rotation of the entire system.</p>",
            'L2': "<h3>Layer 2: The Lattice (Mode E)</h3><p class='text-cyan-300'>The Data Grid.</p><p class='text-sm'>Surrounding the core is the 64-bit SHD-CCP lattice. This layer maps the discrete bits of the Einstein Tile onto the continuous manifold surface. It handles the bulk of the Strassen computation.</p>",
            'L3': "<h3>Layer 3: The Skeleton (Mode B)</h3><p class='text-purple-300'>The Hyper-Pair Ribs.</p><p class='text-sm'>A tesseract-derived structural framework. These 16 nodes define the major and minor axes of rotation, maintaining structural integrity preventing topological collapse.</p>",
            'L4': "<h3>Layer 4: The Interface (Mode A)</h3><p class='text-yellow-300'>The Holographic Shell.</p><p class='text-sm'>The outer projection visible in 3D space. This 'shadow' acts as the I/O boundary, allowing the 4D torus to interact with Euclidean coordinates.</p>",
            'ALL': "<h3>Combined Nesting</h3><p class='text-white'>The Full Hopf Fibration.</p><p class='text-sm'>When nested, these layers form a cohesive topological machine. Data flows from the L4 Interface, filters through the L3 Skeleton, is processed in the L2 Lattice, and synced at the L1 Core.</p>"
        };

        function setLayer(layer) {
            // Update Text
            layerDesc.innerHTML = layerInfos[layer];
            
            // Update Buttons
            ['L1','L2','L3','L4','ALL'].forEach(l => {
                const btn = document.getElementById(`btn-${l}`);
                if (l === layer) {
                    btn.className = "px-4 py-2 text-xs font-bold rounded-t bg-slate-700 text-white border-b-2 border-white transition-colors";
                    // Color code borders
                    if(l==='L1') btn.classList.add('border-blue-500', 'bg-blue-900/50', 'text-blue-300');
                    if(l==='L2') btn.classList.add('border-cyan-500', 'bg-cyan-900/50', 'text-cyan-300');
                    if(l==='L3') btn.classList.add('border-purple-500', 'bg-purple-900/50', 'text-purple-300');
                    if(l==='L4') btn.classList.add('border-yellow-500', 'bg-yellow-900/50', 'text-yellow-300');
                    btn.classList.remove('text-slate-400', 'hover:bg-slate-800', 'bg-slate-700');
                } else {
                    btn.className = "px-4 py-2 text-xs font-bold rounded-t hover:bg-slate-800 text-slate-400 border-b-2 border-transparent transition-colors";
                }
            });

            // Update SVG Opacity
            ['L1','L2','L3','L4'].forEach(l => {
                const el = document.getElementById(`svg-${l}`);
                if (layer === 'ALL') {
                    el.setAttribute('opacity', '1');
                } else {
                    el.setAttribute('opacity', l === layer ? '1' : '0.1');
                }
            });
        }
        
        setLayer('ALL'); // Init

        // --- 4. 3D STAR TOPOLOGY VISUALIZER (SECTION 6) ---
        (function initStarTopology() {
            const container = document.getElementById('star-topology-3d');
            const w = container.clientWidth;
            const h = container.clientHeight;
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617);
            
            const camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 1000);
            camera.position.set(0, 15, 30);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(w, h);
            container.appendChild(renderer.domElement);
            
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // HELPERS
            const phi = 1.618;
            
            // --- PI 6: CENTER HEXAGRAM (Double Triangle) ---
            const hexGroup = new THREE.Group();
            
            // Up Triangle
            const triGeo = new THREE.BufferGeometry();
            const r6 = 5;
            const triVerts1 = [];
            for(let i=0; i<3; i++) {
                const a = (i/3)*Math.PI*2 + Math.PI/6;
                triVerts1.push(Math.cos(a)*r6, 0, Math.sin(a)*r6);
            }
            triVerts1.push(triVerts1[0], triVerts1[1], triVerts1[2]); // close
            triGeo.setAttribute('position', new THREE.Float32BufferAttribute(triVerts1, 3));
            const tri1 = new THREE.Line(triGeo, new THREE.LineBasicMaterial({ color: 0x22d3ee }));
            
            // Down Triangle
            const triGeo2 = new THREE.BufferGeometry();
            const triVerts2 = [];
            for(let i=0; i<3; i++) {
                const a = (i/3)*Math.PI*2 - Math.PI/6;
                triVerts2.push(Math.cos(a)*r6, 0, Math.sin(a)*r6);
            }
            triVerts2.push(triVerts2[0], triVerts2[1], triVerts2[2]);
            triGeo2.setAttribute('position', new THREE.Float32BufferAttribute(triVerts2, 3));
            const tri2 = new THREE.Line(triGeo2, new THREE.LineBasicMaterial({ color: 0x22d3ee }));
            
            hexGroup.add(tri1);
            hexGroup.add(tri2);
            scene.add(hexGroup);

            // --- VIRTUAL PACKET (DENSITY) ---
            const packetGroup = new THREE.Group();
            
            // 1. Override Core (Icosahedron)
            const coreGeo = new THREE.IcosahedronGeometry(1.5, 0);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
            const core = new THREE.Mesh(coreGeo, coreMat);
            packetGroup.add(core);
            
            // 2. Perspective Pointers (Rings)
            const ringGeo = new THREE.TorusGeometry(2.5, 0.05, 8, 32);
            const ring1 = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0x06b6d4 })); // Cyan
            const ring2 = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xd946ef })); // Magenta
            const ring3 = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0xeab308 })); // Yellow
            
            ring1.rotation.x = Math.PI/2;
            ring2.rotation.y = Math.PI/2;
            
            packetGroup.add(ring1);
            packetGroup.add(ring2);
            packetGroup.add(ring3);
            
            // 3. Volumetric Density (Particles)
            const partGeo = new THREE.BufferGeometry();
            const partCount = 100;
            const posArr = new Float32Array(partCount * 3);
            for(let i=0; i<partCount*3; i++) {
                posArr[i] = (Math.random() - 0.5) * 4;
            }
            partGeo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            const partMat = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff, transparent: true, opacity: 0.5 });
            const particles = new THREE.Points(partGeo, partMat);
            packetGroup.add(particles);

            scene.add(packetGroup);


            // --- PI 5: BOTTOM PENTAGRAM (Phi lower) ---
            const r5 = r6 / phi; 
            const y5 = -8;
            const pentGroup = new THREE.Group();
            
            // Regular Pentagram
            const pentGeo = new THREE.BufferGeometry();
            const pentVerts = [];
            const order = [0, 2, 4, 1, 3, 0];
            for(let k of order) {
                const a = (k/5)*Math.PI*2 - Math.PI/2;
                pentVerts.push(Math.cos(a)*r5, y5, Math.sin(a)*r5);
            }
            pentGeo.setAttribute('position', new THREE.Float32BufferAttribute(pentVerts, 3));
            const pent = new THREE.Line(pentGeo, new THREE.LineBasicMaterial({ color: 0xfacc15 }));
            pentGroup.add(pent);

            // Inverse Pentagram (Holographic Inverse - 75% Opacity)
            const pentInv = pent.clone();
            pentInv.rotation.y = Math.PI/5; // 36 deg rotation for decagon projection
            pentInv.material = new THREE.LineBasicMaterial({ color: 0xfacc15, transparent: true, opacity: 0.75 });
            pentGroup.add(pentInv);
            
            scene.add(pentGroup);

            // --- PI 7: TOP HEPTAGRAM (Phi higher) ---
            const r7 = r6 * phi;
            const y7 = 8;
            const heptGroup = new THREE.Group();
            
            // Regular Heptagram {7/3}
            const heptGeo = new THREE.BufferGeometry();
            const heptVerts = [];
            // Star path 0->3->6->2->5->1->4->0
            const order7 = [0, 3, 6, 2, 5, 1, 4, 0];
            for(let k of order7) {
                const a = (k/7)*Math.PI*2 - Math.PI/2;
                heptVerts.push(Math.cos(a)*r7, y7, Math.sin(a)*r7);
            }
            heptGeo.setAttribute('position', new THREE.Float32BufferAttribute(heptVerts, 3));
            const hept = new THREE.Line(heptGeo, new THREE.LineBasicMaterial({ color: 0xec4899 }));
            heptGroup.add(hept);

            // Inverse Heptagram (Holographic Inverse - 75% Opacity)
            const heptInv = hept.clone();
            heptInv.rotation.y = Math.PI/7; // ~25.7 deg rotation
            heptInv.material = new THREE.LineBasicMaterial({ color: 0xec4899, transparent: true, opacity: 0.75 });
            heptGroup.add(heptInv);

            scene.add(heptGroup);

            // --- PI 12: OUTER CATCH-ALL (Cage) ---
            const cageGeo = new THREE.IcosahedronGeometry(18, 1);
            const cageMat = new THREE.MeshBasicMaterial({ color: 0x64748b, wireframe: true, transparent: true, opacity: 0.1 });
            const cage = new THREE.Mesh(cageGeo, cageMat);
            scene.add(cage);
            
            // Connection Lines (Flow)
            const linesMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1 });
            const linesGeo = new THREE.BufferGeometry();
            const linesVerts = [];
            for(let i=0; i<8; i++) {
                linesVerts.push(0, y5, 0); // Bottom center
                linesVerts.push(Math.cos(i)*r6, 0, Math.sin(i)*r6); // Mid ring
                linesVerts.push(0, y7, 0); // Top center
            }
            linesGeo.setAttribute('position', new THREE.Float32BufferAttribute(linesVerts, 3));
            const lines = new THREE.LineSegments(linesGeo, linesMat);
            scene.add(lines);

            function animateStar() {
                requestAnimationFrame(animateStar);
                controls.update();
                
                // Rotations
                hexGroup.rotation.y += 0.01;
                pentGroup.rotation.y -= 0.005; // Counter
                heptGroup.rotation.y += 0.002;
                cage.rotation.y += 0.001;
                cage.rotation.z += 0.001;
                
                // Packet Animation
                ring1.rotation.x += 0.02;
                ring2.rotation.y += 0.02;
                ring3.rotation.z += 0.02;
                core.rotation.x -= 0.01;
                core.rotation.y -= 0.01;
                const s = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                core.scale.set(s,s,s);
                
                renderer.render(scene, camera);
            }
            animateStar();
            
            // Resize logic local to this canvas
            // (Simplified: assuming window resize handles main camera only, 
            // for robust multiple canvas handling, ResizeObserver is best but standard resize listener is okay for demo)
        })();

        // --- 5. ZETA FUNCTION VISUALIZER (SECTION 7) ---
        (function initZetaVisualizer() {
            // 2D CANVAS
            const canvas2d = document.getElementById('zeta-2d');
            if (canvas2d) {
                const ctx = canvas2d.getContext('2d');
                let t = 0;
                
                function drawZeta() {
                    if (canvas2d.width !== canvas2d.clientWidth) {
                        canvas2d.width = canvas2d.clientWidth;
                        canvas2d.height = canvas2d.clientHeight;
                    }
                    const w = canvas2d.width;
                    const h = canvas2d.height;
                    const cx = w/2;
                    const cy = h/2;
                    
                    // Fade trail
                    ctx.fillStyle = 'rgba(2, 6, 23, 0.1)';
                    ctx.fillRect(0, 0, w, h);
                    
                    t += 0.05;
                    const cycle = (t / (Math.PI*2)) % 8; // 0-7 cycles
                    
                    ctx.beginPath();
                    ctx.strokeStyle = '#22d3ee';
                    ctx.lineWidth = 2;
                    
                    // Spirograph logic
                    // R changes per cycle to create flower
                    const R = 50; 
                    const r = 30;
                    const p = 20; 
                    
                    // Logic: Cycle 0-5 = Stable, Cycle 6-7 = Escape
                    let x, y;
                    
                    if (cycle < 6) {
                        // Stable loop
                        const loops = 6; 
                        // Simulate flower: hypotrochoid
                        x = cx + (R - r) * Math.cos(t) + p * Math.cos(((R - r) / r) * t);
                        y = cy + (R - r) * Math.sin(t) - p * Math.sin(((R - r) / r) * t);
                        ctx.strokeStyle = `hsl(${t*10}, 80%, 50%)`;
                    } else {
                        // Escape: Logarithmic Spiral
                        const escapeT = t; // continuous
                        const radius = 10 * Math.exp(0.15 * (escapeT % 10)); // Log growth
                        x = cx + radius * Math.cos(escapeT * 2);
                        y = cy + radius * Math.sin(escapeT * 2);
                        ctx.strokeStyle = '#f472b6'; // Pink for escape
                        ctx.lineWidth = 3;
                        
                        // Draw text warning
                        ctx.fillStyle = '#f472b6';
                        ctx.fillText("ESCAPE VELOCITY", 10, 20);
                    }
                    
                    // Draw point/trail
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI*2);
                    ctx.stroke();
                    
                    requestAnimationFrame(drawZeta);
                }
                drawZeta();
            }

            // 3D CANVAS (THREE.JS)
            const container3d = document.getElementById('zeta-3d');
            if (container3d) {
                const w = container3d.clientWidth;
                const h = container3d.clientHeight;
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x020617);
                const camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 100);
                camera.position.set(0, 20, 30);
                camera.lookAt(0,0,0);
                
                const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(w, h);
                container3d.appendChild(renderer.domElement);
                
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                
                // 12-Point Cage (Reset Boundary)
                const cageGeo = new THREE.IcosahedronGeometry(12, 0);
                const cageMat = new THREE.MeshBasicMaterial({ color: 0x64748b, wireframe: true, transparent: true, opacity: 0.3 });
                const cage = new THREE.Mesh(cageGeo, cageMat);
                scene.add(cage);
                
                // Particle Stream
                const streamGeo = new THREE.BufferGeometry();
                const streamCount = 200;
                const posArr = new Float32Array(streamCount * 3);
                streamGeo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
                const streamMat = new THREE.PointsMaterial({ color: 0xfacc15, size: 0.3 });
                const stream = new THREE.Points(streamGeo, streamMat);
                scene.add(stream);
                
                let time3d = 0;
                
                function animate3d() {
                    requestAnimationFrame(animate3d);
                    controls.update();
                    time3d += 0.05;
                    
                    // Update particles
                    const positions = stream.geometry.attributes.position.array;
                    for(let i=0; i<streamCount; i++) {
                        // Each particle represents a moment in the cycle
                        const t = time3d - (i * 0.1);
                        
                        // Parametric path: Spiral out -> Hit 12 -> Spiral In
                        const modT = t % 20; 
                        let r, y, angle;
                        
                        if (modT < 10) {
                            // Expanding (Escape)
                            r = modT * 1.2; // Linear out
                            y = modT * 0.5; // Up
                            angle = modT * 2;
                        } else {
                            // Collapsing (Reset)
                            // Invert from 12 back to 0
                            const revT = 20 - modT;
                            r = revT * 1.2;
                            y = revT * 0.5;
                            angle = modT * 2; 
                        }
                        
                        // Apply to array
                        positions[i*3] = Math.cos(angle) * r;
                        positions[i*3+1] = y - 5; // Center vertically
                        positions[i*3+2] = Math.sin(angle) * r;
                    }
                    stream.geometry.attributes.position.needsUpdate = true;
                    
                    renderer.render(scene, camera);
                }
                animate3d();
            }
        })();

        // --- THREE.JS BACKGROUND ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 30);
        
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('viz-container').appendChild(renderer.domElement);

        const geo1 = new THREE.TorusGeometry(8, 3, 32, 100);
        const mat1 = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Vector3(0.0, 0.5, 1.0) }, uDirection: { value: 1.0 } },
            transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
        });
        const torus1 = new THREE.Mesh(geo1, mat1);
        
        const geo2 = new THREE.TorusGeometry(8, 2.9, 32, 100); 
        const mat2 = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Vector3(1.0, 0.2, 0.5) }, uDirection: { value: -1.0 } },
            transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
        });
        const torus2 = new THREE.Mesh(geo2, mat2);
        torus2.rotation.x = Math.PI; 

        const fiberGroup = new THREE.Group();
        for(let i=0; i<24; i++) {
            const g = new THREE.TorusGeometry(8, 0.03, 8, 50);
            const m = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
            const mesh = new THREE.Mesh(g, m);
            mesh.rotation.y = (Math.PI * i) / 24;
            fiberGroup.add(mesh);
        }

        scene.add(torus1);
        scene.add(torus2);
        scene.add(fiberGroup);

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            mat1.uniforms.uTime.value = t;
            mat2.uniforms.uTime.value = t;
            torus1.rotation.x = t * 0.15; torus1.rotation.y = t * 0.1;
            torus2.rotation.x = Math.PI + t * 0.15; torus2.rotation.y = t * 0.1;
            fiberGroup.rotation.x = t * 0.15; fiberGroup.rotation.y = t * 0.1;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
